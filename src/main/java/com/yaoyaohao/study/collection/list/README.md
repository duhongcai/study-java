#  1 List
###  1.1 ArrayList
以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arrayCopy()复制到新数组。因此最好能给出数组大小的预估值。  
默认第一次插入元素时创建大小为10的数组。  
按数组下标访问元素 -- get(i)、set(i,e)的性能 很高，这是数组的基本优势。   
如果按下标插入元素、删除元素 -- add(i,e)、remove(i)、remove(e)，则要用System.arrayCopy()来复制移动部分受影响的元素，
性能会变差。  
越是前面的元素，修改时要移动的元素越多。直接在数组末尾加入元素 --add(e)，删除最后一个元素则无影响。  

###  1.2 LinkedList
以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，每插入一个元素都要构造一个额外的Node对象，也需要额外的链表指针操作。  
按下标访问元素 -- get(i)、set(i,e)会悲剧 的部分遍历链表将指针移动到位（如果i>数组大小的一半，会从末尾移起）。  
插入、删除元素时修改前后节点的指针即可，不再需要复制移动。但还是要部分遍历链表的指针才能移动到下标所指的位置。  
只有在链表两头的操作 -- add()、addFirst()、removeFirst()或用iterator()上的remove()能省掉指针的移动。  
Apache Commons有个TreeNodeList，里面是棵二叉树，可以快速移动指针到位。

###  1.3 CopyOnWriteArrayList
并发优化的ArrayList。基于不可变对象策略，在修改时先复制出一个数组快照来修改，改完后再让内部指针指向新数组。  
因为对快照的修改对读操作来说不可见，所以读读之间不互斥，读写之间也不互斥，只有写写之间要加锁互斥。但复制快照的成本昂贵，典型的
适合读多写少的场景。  
虽然增加了addIfAbsent(e)方法会遍历数组来检查元素是否已存在，性能却不太好。

###  1.4 不足
无论哪种实现，按值返回下标contains(e)、indexOf(e)、remove(e)都需要遍历所有元素进行比较，性能都不会好。   
没有按元素值排序的SortedList。   
除了CopyOnWriteArrayList，再没有其他线程安全又并发优化的实现。  
如果凑合着用Set与Queue中的等价类时会缺少一些List特有的方法如get(i)。  
如果更新频率较高，或数组较大时，还是得用Collections.synchronizedList(list)对所有操作用同一把锁来保证线程安全。